/*
 * Map_robot.cpp
 *
 *  Created on: Apr 24, 2025
 *      Author: APC
 */
#include "Map_robot.h"

int32_t get_encoder(int32_t * value,int32_t * level_count,TIM_HandleTypeDef * htim,int16_t encoder_limit){
	int16_t count_current = __HAL_TIM_GET_COUNTER(htim);

	if((*value) > encoder_limit || (*value) < - encoder_limit){
		(*level_count) += count_current;
		__HAL_TIM_SET_COUNTER(htim,0);
		count_current = 0;
	}

	(*value) = (*level_count) + count_current;

	return (*value);
}
int32_t get_speed(int32_t *cnt, int32_t *realspeed,int32_t * level_count,TIM_HandleTypeDef * htim){
	static uint32_t time_last =0;
	uint16_t period = 1000;
	if(HAL_GetTick() - time_last >= period){
		(*realspeed) = ((*cnt)*60)/ 10000;
		 time_last = HAL_GetTick();
		 __HAL_TIM_SET_COUNTER(htim,0);
		 (*cnt) = 0;
		 (*level_count) = 0;
	}

	return (*realspeed);
}

int32_t get_speedd(TIM_HandleTypeDef * htim,uint16_t limit_encoder,uint16_t Pule_per_rotate){
	int32_t count_current = __HAL_TIM_GET_COUNTER(htim);
	static int32_t level_count = 0,cnt;
	static uint32_t last_timeup =0;
	int32_t speed;
	cnt = level_count + count_current;
	if (abs(cnt) > limit_encoder ){
		level_count+= count_current;
		__HAL_TIM_SET_COUNTER(htim,0);
		count_current =0;
	}
	if (HAL_GetTick() - last_timeup >= 1000){
		speed = (cnt*60)/Pule_per_rotate;
		level_count =0;
		cnt = 0;
		__HAL_TIM_SET_COUNTER(htim,0);
	}
	return speed;

}



